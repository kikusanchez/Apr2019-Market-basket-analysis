c<-c("A","N","O","B")
d<-c("M","A","S","S")
m<- matrix(c(a,b,c,d), nrow=4, ncol=4, byrow = TRUE)
comb_cols<-c()
comb_rows<-c()
find_word<- function(data){
find_word<- function(data){
find_word<- function(data){
find_word<- function(data){
find_word<- function(data){
for (i in 1:ncol(m)) {
keyword<-readline(prompt = "Enter your word: ")
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
print(paste("TRUE at the row ",i))
}
else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
keyword<-readline(prompt = "Enter your word: ")
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
print(paste("TRUE at the row ",y))
}
else {print(paste("FALSE"))}
}
}
find_word(m)
find_word<- function(data){
keyword<-readline(prompt = "Enter your word: ")
for (i in 1:ncol(m)) {
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
print(paste("TRUE at the row ",i))
}
else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
print(paste("TRUE at the row ",y))
}
else {print(paste("FALSE"))}
}
}
find_word(m)
find_word<- function(data){
keyword<-readline(prompt = "Enter your word: ")
for (i in 1:ncol(m)) {
exists<-0
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
print(paste("TRUE at the row ",i))
}
else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
print(paste("TRUE at the row ",y))
}
else {print(paste("FALSE"))}
}
exists<-1
}
find_word(m)
find_word<- function(data){
keyword<-readline(prompt = "Enter your word: ")
for (i in 1:ncol(m)) {
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
print(paste("TRUE in the column ",i))
}
else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
print(paste("TRUE in the row ",y))
}
else {print(paste("FALSE"))}
}
}
find_word(m)
find_word(m)
find_word
find_word(m)
exists<-0
exists<-1
find_word(m)
find_word<- function(data){
keyword<-readline(prompt = "Enter your word: ")
exist<-0
for (i in 1:ncol(m)) {
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
exist<-1
print(paste("TRUE in the column ",i))
}
else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
exist<-1
print(paste("TRUE in the row ",y))
}
if (exist==0)
else {print(paste("FALSE"))}
}
}
find_word<- function(data){
keyword<-readline(prompt = "Enter your word: ")
exist<-0
for (i in 1:ncol(m)) {
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
exist<-1
print(paste("TRUE in the column ",i))
}
else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
exist<-1
print(paste("TRUE in the row ",y))
}
if (exist==0){}
else {print(paste("FALSE"))}
}
}
find_word(m)
find_word<- function(data){
keyword<-readline(prompt = "Enter your word: ")
exist<-0
for (i in 1:ncol(m)) {
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
exist<-1
print(paste("TRUE in the column ",i))
}
else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
exist<-1
print(paste("TRUE in the row ",y))
}
else {print(paste("FALSE"))}
}
if (exists==0)
print("FAIL")
}
find_word(m)
find_word<- function(data){
keyword<-readline(prompt = "Enter your word: ")
exist<-0
for (i in 1:ncol(m)) {
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
exist<-1
print(paste("TRUE in the column ",i))
}
#else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
exist<-1
print(paste("TRUE in the row ",y))
}
#else {print(paste("FALSE"))}
}
if (exists==0)
print("FAIL")
}
find_word(m)
find_word(m)
find_word(m)
ANOB
find_word(m)
find_word(m)
find_word<- function(data){
keyword<-readline(prompt = "Enter your word: ")
exist<-0
for (i in 1:ncol(m)) {
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
exist<-1
print(paste("TRUE in the column ",i))
}
#else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
exist<-1
print(paste("TRUE in the row ",y))
}
#else {print(paste("FALSE"))}
}
if (exists==0){
print("FAIL")
}
}
find_word(m)
find_word(m)
find_word(m)
find_word(m)
exist<-0
if (exists==0){
print("FAIL")
}
find_word<- function(data){
keyword<-readline(prompt = "Enter your word: ")
exist<-0
for (i in 1:ncol(m)) {
comb_cols<-paste(m[,i], collapse = "")
if (grepl(keyword, comb_cols)){
exist<-1
print(paste("TRUE in the column ",i))
}
#else {print(paste("FALSE"))}
}
for (y in 1:nrow(m)) {
comb_rows<-paste(m[y,], collapse = "")
if (grepl(comb_rows, keyword)){
exist<-1
print(paste("TRUE in the row ",y))
}
#else {print(paste("FALSE"))}
}
if (exist==0){
print("FAIL")
}
}
find_word(m)
find_word(m)
remove(exists)
TempDFB2B2
#### 0. INCLUDES ####
#Load Libraries: p_load can install, load,  and update packages
if(require("pacman")=="FALSE"){
install.packages("pacman")
}
#### 0. INCLUDES ####
#Load Libraries: p_load can install, load,  and update packages
if(require("pacman")=="FALSE"){
install.packages("pacman")
}
pacman::p_load(rstudioapi, dplyr,magrittr, tidyr, reshape2, readxl, stringi,
ggplot2,caret,corrplot,rpart,e1071,arules,arulesViz,gdata)
# Setwd (1ยบ current wd where is the script, then we move back to the
# general folder)
current_path = getActiveDocumentContext()$path
setwd(dirname(current_path))
setwd("..")
rm(current_path)
#Original Data set
electronidex<-read.transactions("../market_basket_analysis/datasets/ElectronidexTransactions2017.csv",
format = "basket", header = FALSE, sep = ",", cols=NULL, rm.duplicates = FALSE,
quote = "\"'", skip = 0,encoding = "unknown")
#b2b splitted data set
b2b<-read.transactions("../market_basket_analysis/datasets/B2BTransacs.csv", header = T, sep = ",")
#b2c splitted data set
b2c<-read.transactions("../market_basket_analysis/datasets/B2CTransacs.csv", header = T, sep = ",")
#data set cointaining all Electronidex products with their category in the name
master_products<-read.csv("../market_basket_analysis/info/Master_products_categories.csv",header = FALSE, sep = ",")
#data set cointaining unique categories for blackwells and electronidex items
categories<-read.csv("../market_basket_analysis/datasets/ProductCategories(Blackwell_and_Electronidex).csv",header = TRUE, sep = ",")
# ELECTRONIDEX CATEGORIES
#data set cointaining all Electronidex products with their category in the name
master_products<-read.csv("../market_basket_analysis/info/Master_products_categories.csv",header = FALSE, sep = ",")
#transform data into a vector
master_products<-as.vector(t(master_products))
summary(master_products)
#replacing item's names with their respective category:
master_products[grep("Laptops.",master_products)]<-"laptop"
master_products[grep("Desktop.",master_products)]<-"desktop"
master_products[grep("Monitors.",master_products)]<-"monitor"
master_products[grep("Computer.Mice",master_products)]<-"mouse"
master_products[grep("Keyboard.",master_products)]<-"keyboard"
master_products[grep("Mouse.and.Keyboard.Combo.",master_products)]<-"M&K_combo"
master_products[grep("Computer.Headphones.",master_products)]<-"compu_headphone"
master_products[grep("Active.Headphones.",master_products)]<-"active_headphone"
master_products[grep("Computer.Cords.",master_products)]<-"compu_cord"
master_products[grep("Accessories.",master_products)]<-"accessory"
master_products[grep("Speakers.",master_products)]<-"speaker"
master_products[grep("Printers.",master_products)]<-"printer"
master_products[grep("Printer.Ink.",master_products)]<-"printer_ink"
master_products[grep("Computer.Stands.",master_products)]<-"compu_stand"
master_products[grep("Computer.Tablets.",master_products)]<-"tablet"
master_products[grep("External.Hardrives.",master_products)]<-"ext_hardrive"
master_products[grep("Smart.Home.Devices.",master_products)]<-"smart_home"
print(master_products)
# ELECTRONIDEX BRANDS
#reading the csv cointaining all products with their category in the name
master_products2<-read.csv("../market_basket_analysis/info/Master_products_categories.csv",header = FALSE, sep = ",")
#transform data into a vector
master_products2<-as.vector(t(master_products2))
summary(master_products2)
#replacing item's names with their respective brand:
master_products2[grep("Apple",master_products2)]<-"apple"
master_products2[grep("iMac",master_products2)]<-"apple"
master_products2[grep("iPhone",master_products2)]<-"apple"
master_products2[grep("iPad",master_products2)]<-"apple"
master_products2[grep("Acer",master_products2)]<-"acer"
master_products2[grep("Alienware",master_products2)]<-"alienware"
master_products2[grep("ASUS",master_products2)]<-"asus"
master_products2[grep("Dell",master_products2)]<-"dell"
master_products2[grep("HP",master_products2)]<-"hp"
master_products2[grep("Lenovo",master_products2)]<-"lenovo"
master_products2[grep("Logitech",master_products2)]<-"logitech"
master_products2[grep("Samsung",master_products2)]<-"samsung"
master_products2[grep("Belkin",master_products2)]<-"belkin"
master_products2[grep("Brother",master_products2)]<-"brother"
master_products2[grep("Canon",master_products2)]<-"canon"
master_products2[grep("Cambridge",master_products2)]<-"cambridge"
master_products2[grep("Cyber",master_products2)]<-"cyber"
master_products2[grep("DOSS",master_products2)]<-"doss"
master_products2[grep("DYMO",master_products2)]<-"dymo"
master_products2[grep("Eluktronics",master_products2)]<-"eluktronics"
master_products2[grep("Fire",master_products2)]<-"amazon"
master_products2[grep("Google",master_products2)]<-"google"
master_products2[grep("Halter",master_products2)]<-"halter"
master_products2[grep("XIBERIA",master_products2)]<-"xiberia"
master_products2[grep("Mackie",master_products2)]<-"mackie"
master_products2[grep("Kensington",master_products2)]<-"kensington"
master_products2[grep("Koss",master_products2)]<-"koss"
master_products2[grep("Monster",master_products2)]<-"monster"
master_products2[grep("Otium",master_products2)]<-"otium"
master_products2[grep("Rokono",master_products2)]<-"rokono"
master_products2[grep("LG",master_products2)]<-"lg"
master_products2[grep("JBL",master_products2)]<-"jbl"
master_products2[grep("Otium",master_products2)]<-"otium"
master_products2[grep("Ailihen",master_products2)]<-"ailihen"
master_products2[grep("ViewSonic",master_products2)]<-"viewsonic"
master_products2[grep("Sonos",master_products2)]<-"sonos"
master_products2[grep("Sceptre",master_products2)]<-"sceptre"
master_products2[grep("Rii",master_products2)]<-"rii"
master_products2[grep("Redragon",master_products2)]<-"redragon"
master_products2[grep("Panasonic",master_products2)]<-"panasonic"
master_products2[grep("Microsoft",master_products2)]<-"microsoft"
master_products2[grep("Roku",master_products2)]<-"roku"
master_products2[grep("Philips",master_products2)]<-"philips"
master_products2[grep("LG",master_products2)]<-"lg"
master_products2[grep("Kindle",master_products2)]<-"kindle"
master_products2[grep("EagleTec",master_products2)]<-"eagletec"
master_products2[grep("Epson",master_products2)]<-"epson"
master_products2[grep("Etekcity",master_products2)]<-"etekcity"
master_products2[grep("AOC",master_products2)]<-"aoc"
master_products2[grep("APIE",master_products2)]<-"apie"
master_products2[grep("Backlit",master_products2)]<-"backlit"
master_products2[grep("Bose",master_products2)]<-"bose"
master_products2[grep("CYBERPOWER",master_products2)]<-"cyberpower"
master_products2[grep("Intel",master_products2)]<-"intel"
master_products2[grep("Cable",master_products2)]<-"unknown"
master_products2[grep("Adapter",master_products2)]<-"unknown"
master_products2[grep("Hardrives",master_products2)]<-"unknown"
master_products2[grep("Computer",master_products2)]<-"unknown"
master_products2[grep("Pad",master_products2)]<-"unknown"
master_products2[grep("Bulb",master_products2)]<-"unknown"
print(master_products2)
#### B2B RULES ####
b2b<-read.transactions("../market_basket_analysis/datasets/B2BTransacs.csv", header = T, sep = ",")
str(b2b)
#Rules b2b
Rules_b2b<- apriori (b2b, parameter = list(supp = 0.002, conf = 0.8, minlen=1))
#looking for redundant rules
is.redundant(Rules_b2b)
#show if there are redundant rules
which(is.redundant(Rules_b2b), arr.ind = TRUE, useNames = TRUE)
#removing redundant rules
Rules_b2b <- Rules_b2b[!is.redundant(Rules_b2b)]
#confirming there are'nt more redundant rules
is.redundant(Rules_b2b)
#rules.sorted<-sort(Rules_b2b, by="lift")
#inspect(Rules_b2b)
ruleExplorer(Rules_b2b)
#creating transactional for categories
B2B_categories<- aggregate(b2b, by = "categories")
#creating transactional for categories
B2B_categories<- aggregate(b2b, by = "categories")
#adding renamed Electronidex items into categories level
b2b@itemInfo$categories<-master_products
str(b2b)
#creating transactional for categories
B2B_categories<- aggregate(b2b, by = "categories")
str(B2B_categories)
B2B_categories
#creating the rules
Rules_b2b_electronidex_cat<- apriori (b2b, parameter = list(supp = 0.002, conf = 0.8, minlen=1))
#looking for redundant rules
is.redundant(Rules_b2b_electronidex_cat)
#show if there are redundant rules
which(is.redundant(Rules_b2b_electronidex_cat), arr.ind = TRUE, useNames = TRUE)
#removing redundant rules
Rules_b2b_cat <- Rules_b2b_electronidex_cat[!is.redundant(Rules_b2b_electronidex_cat)]
#confirming there are'nt more redundant rules
is.redundant(Rules_b2b_cat)
#rules.sorted<-sort(Rules_b2b_cat, by="lift")
#inspect(Rules_b2b_cat)
ruleExplorer(Rules_b2b_cat)
#MIXING BLACKWELLS CATEGORIES AND ELECTRONIDEX CATEGORIES
#reading the csv cointaining all products with their category in the name
categories<-read.csv("../market_basket_analysis/datasets/ProductCategories(Blackwell_and_Electronidex).csv",header = TRUE, sep = ",")
categories
#leaving empty labels level in transactional file and putting it into a data frame
TempDFB2B <- as.data.frame(b2b@itemInfo$labels )
#renaming first column of the data frame
colnames(TempDFB2B)[1] <- "ProdName"
TempDFB2B
#merging the column ProdName of categories file and the column ProdName of TempDFB2B into only 1 column
TempDFB2B2 <- merge(TempDFB2B, categories, by.x="ProdName", by.y="ProdName")
#putting the values of BWCat column of the data set into the categories level of transactional file
b2b@itemInfo$categories <- TempDFB2B2$BWCat
#Rules b2b by categories
Rules_b2b_unique_cat<- apriori (TempDFB2B2, parameter = list(maxlen=3, supp = 0.003, conf = 0.6, minlen=1))
#looking for redundant rules
is.redundant(Rules_b2b_unique_cat)
#show if there are redundant rules
which(is.redundant(Rules_b2b_unique_cat), arr.ind = TRUE, useNames = TRUE)
#removing redundant rules
Rules_b2b_unique <- Rules_b2b_unique_cat[!is.redundant(Rules_b2b_unique_cat)]
#confirming there are'nt more redundant rules
is.redundant(Rules_b2b_unique)#rules.sorted<-sort(Rules_b2b_categories, by="lift")
#inspect(Rules_b2b_categories)
ruleExplorer(Rules_b2b_unique)
#adding renamed Electronidex items into brands level
b2b@itemInfo$brands<-master_products2
str(b2b)
#creating transactional for brands
B2B_brands <- aggregate(b2b, by = "brands")
str(B2B_brands)
#Rules b2b by brands
Rules_b2b_brands<- apriori (B2B_brands, parameter = list(supp = 0.01, conf = 0.7, minlen=1))
#rules.sorted<-sort(Rules_b2b_brands, by="lift")
#inspect(Rules_b2b_brands)
ruleExplorer(Rules_b2b_brands)
#removing redundant rules
Rules_b2b_brands <- Rules_b2b_brands[!is.redundant(Rules_b2b_brands)]
#confirming there are'nt more redundant rules
is.redundant(Rules_b2b_brands)#rules.sorted<-sort(Rules_b2b_categories, by="lift")
#adding renamed items into categories level
b2c@itemInfo$categories<-master_products
str(b2c)
#creating transactional for categories
B2C_categories <- aggregate(b2c, by = "categories")
str(B2C_categories)
#Rules b2c by categories
Rules_b2c_categories<- apriori (B2C_categories, parameter = list(supp = 0.01, conf = 0.7, minlen=1))
#looking for redundant rules
is.redundant(Rules_b2c_categories)
#show if there are redundant rules
which(is.redundant(Rules_b2c_categories), arr.ind = TRUE, useNames = TRUE)
#removing redundant rules
Rules_b2c_categories <- Rules_b2c_categories[!is.redundant(Rules_b2c_categories)]
#confirming there are'nt more redundant rules
is.redundant(Rules_b2c_categories)
#rules.sorted<-sort(Rules_b2c_categories, by="lift")
#inspect(Rules_b2c_categories)
ruleExplorer(Rules_b2c_categories)
#Rules b2c by categories
Rules_b2c_categories<- apriori (B2C_categories, parameter = list(supp = 0.001, conf = 0.7, minlen=1))
#looking for redundant rules
is.redundant(Rules_b2c_categories)
#show if there are redundant rules
which(is.redundant(Rules_b2c_categories), arr.ind = TRUE, useNames = TRUE)
#removing redundant rules
Rules_b2c_categories <- Rules_b2c_categories[!is.redundant(Rules_b2c_categories)]
#confirming there are'nt more redundant rules
is.redundant(Rules_b2c_categories)
#rules.sorted<-sort(Rules_b2c_categories, by="lift")
#inspect(Rules_b2c_categories)
ruleExplorer(Rules_b2c_categories)
TempDFB2C <- as.data.frame(b2c@itemInfo$labels )
colnames(TempDFB2C)[1] <- "ProdName"
TempDFB2C
TempDFB2C2 <- merge(TempDFB2C, categories, by.x="ProdName", by.y="ProdName")
b2c@itemInfo$categories <- TempDFB2C2$BWCat
#Rules b2c Blackwells & Electronidex
Rules_b2c_unique_cat<- apriori (b2c, parameter = list(supp = 0.005, conf = 0.7, minlen=1))
#Rules b2c Blackwells & Electronidex
Rules_b2c_unique_cat<- apriori (b2c, parameter = list(supp = 0.001, conf = 0.7, minlen=1))
#looking for redundant rules
is.redundant(Rules_b2c_unique_cat)
#show if there are redundant rules
which(is.redundant(Rules_b2c_unique_cat), arr.ind = TRUE, useNames = TRUE)
#removing redundant rules
Rules_b2c_unique_cat <- Rules_b2c_unique_cat[!is.redundant(Rules_b2c_unique_cat)]
#confirming there are'nt more redundant rules
is.redundant(Rules_b2c_unique_cat)
#rules.sorted<-sort(Rules_b2c_unique_cat, by="lift")
#inspect(Rules_b2c_unique_cat)
ruleExplorer(Rules_b2c_unique_cat)
#transform data into a vector
master_products2<-as.vector(t(master_products2))
#transform data into a vector
master_products2<-as.vector(t(master_products2))
summary(master_products2)
#adding renamed items into brands level
b2c@itemInfo$brands<-master_products2
str(b2c)
#creating transactional for brands
B2C_brands <- aggregate(b2c, by = "brands")
str(B2C_brands)
#Rules b2c by brands
Rules_b2c_brands<- apriori (B2C_brands, parameter = list(supp = 0.001, conf = 0.6, minlen=1))
#checking the vector
TempDFB2B
